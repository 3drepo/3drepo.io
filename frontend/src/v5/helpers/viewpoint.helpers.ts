/**
 *  Copyright (C) 2023 3D Repo Ltd
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
import { Viewpoint, Group, ViewpointGroupOverrideType, GroupOverride, ViewpointState, V4GroupObjects, OverridesDicts, MeshIdTransformDict } from '@/v5/store/tickets/tickets.types';
import { getGroupHexColor, rgbaToHex } from '@/v4/helpers/colors';
import { generateViewpoint as generateViewpointV4, getNodesIdsFromSharedIds, toSharedIds } from '@/v4/helpers/viewpoints';
import { formatMessage } from '@/v5/services/intl';
import { dispatch, getState } from '@/v4/modules/store';
import { isEmpty } from 'lodash';
import { Viewer as ViewerService } from '@/v4/services/viewer/viewer';
import { TreeActions } from '@/v4/modules/tree';
import { ViewerGuiActions } from '@/v4/modules/viewerGui';
import { selectCurrentTeamspace } from '../store/teamspaces/teamspaces.selectors';
import { TicketsCardActionsDispatchers } from '../services/actionsDispatchers';

export const convertToV5GroupNodes = (objects) => objects.map((object) => ({
	container: object.model as string,
	_ids: getNodesIdsFromSharedIds([object]),
}));

export const convertToV4GroupNodes = (objects = []) => objects.map(({ container: model, _ids }) => ({
	account: selectCurrentTeamspace(getState()),
	model,
	shared_ids: toSharedIds(_ids),
}));

const convertToV5GroupOverride = (group: any, type: ViewpointGroupOverrideType): GroupOverride => {
	let description = '';
	let name = '';
	switch (type) {
		case ViewpointGroupOverrideType.COLORED:
			const color = rgbaToHex(group.color.join(','));
			description = formatMessage({ id: 'viewpoint.autogeneratedColoredGroup.description', defaultMessage: 'Autogenerated group from viewer for colour {color}' }, { color });
			name = formatMessage({ id: 'viewpoint.autogeneratedColoredGroup.name', defaultMessage: 'Default {color} group' }, { color });
			break;
		case ViewpointGroupOverrideType.TRANSFORMED:
			description = formatMessage({ id: 'viewpoint.autogeneratedTransformedGroup.description', defaultMessage: 'Autogenerated group from viewer for transform' });
			name = formatMessage({ id: 'viewpoint.autogeneratedTransformedGroup.name', defaultMessage: 'Default transform' });
			break;
		default:
			description = formatMessage({ id: 'viewpoint.autogeneratedHiddenGroup.description', defaultMessage: 'Autogenerated hidden group from viewer' });
			name = formatMessage({ id: 'viewpoint.autogeneratedHiddenGroup.name', defaultMessage: 'Default hidden' });
			break;
	}

	const override:GroupOverride = { group: { description, name } };

	(override.group as Group).objects = convertToV5GroupNodes(group.objects);

	if (group.color) {
		const { color } = group;
		if (color.length > 3) {
			override.opacity = color.pop() / 255;
		}
		override.color = color;
	}

	if (group.opacity) {
		const { opacity } = group;
		override.opacity = opacity;
	}

	if (group.transformation) {
		const { transformation } = group;
		override.transformation = transformation;
	}


	return override;
};

export const getViewerState = async () => {
	const { viewpoint: viewpointV4 } = await generateViewpointV4();

	const state: ViewpointState = { showHidden: !viewpointV4.hideIfc };

	if (viewpointV4.override_groups?.length) {
		state.colored = viewpointV4.override_groups.map((group) => convertToV5GroupOverride(group, ViewpointGroupOverrideType.COLORED));
	}

	if (viewpointV4.highlighted_group) {
		state.colored = (state.colored || []).concat(convertToV5GroupOverride(viewpointV4.highlighted_group, ViewpointGroupOverrideType.COLORED));
	}

	if (viewpointV4.hidden_group) {
		state.hidden = [convertToV5GroupOverride(viewpointV4.hidden_group, ViewpointGroupOverrideType.HIDDEN)];
	}

	if (viewpointV4.transformation_groups) {
		state.transformed = viewpointV4.transformation_groups.map((group) => convertToV5GroupOverride(group, ViewpointGroupOverrideType.TRANSFORMED));
	}

	return state;
};

export const meshObjectsToV5GroupNode = (objects) => objects.map((obj) => ({
	container: obj.model,
	_ids: obj.mesh_ids,
}));

export const toGroupPropertiesDicts = (overrides: GroupOverride[]): OverridesDicts => {
	const toMeshDictionary = (objects: V4GroupObjects, color: string, opacity: number): OverridesDicts => 
		objects.shared_ids.reduce((dict, id) => {
			if (color !== undefined) {
			// eslint-disable-next-line no-param-reassign
				dict.overrides[id] = color;
			}

			if (opacity !== undefined) {
			// eslint-disable-next-line no-param-reassign
				dict.transparencies[id] = opacity;
			}

			return dict;
		}, { overrides: {}, transparencies: {} } as OverridesDicts);

	return overrides.reduce((acum, current) => {
		const color = current.color ? getGroupHexColor(current.color) : undefined;
		const { opacity } = current;
		const v4Objects = convertToV4GroupNodes((current.group as Group)?.objects || []);

		return v4Objects.reduce((dict, objects) => {
			const overrideDict = toMeshDictionary(objects, color, opacity);

			// eslint-disable-next-line no-param-reassign
			dict.overrides = { ...dict.overrides, ...overrideDict.overrides };
			// eslint-disable-next-line no-param-reassign
			dict.transparencies = { ...dict.transparencies, ...overrideDict.transparencies };

			return dict;
		}, acum);
	}, { overrides: {}, transparencies: {} } as OverridesDicts);
};

const toTranformationsDict = (overrides: GroupOverride[]): MeshIdTransformDict => {
	const dict: MeshIdTransformDict = {};

	overrides.forEach((current) => {
		const v4Objects = convertToV4GroupNodes((current.group as Group)?.objects || []);
		v4Objects.forEach((obj) => 
			obj.shared_ids.forEach((id) => 
				dict[id] = current.transformation,
			));
	});

	return dict;
};

export const goToView = async (view: Viewpoint) => {
	if (
		isEmpty(view?.state?.colored) && 
		isEmpty(view?.state?.hidden) && 
		isEmpty(view?.state?.transformed) && 
		isEmpty(view?.camera) && 
		isEmpty(view?.clippingPlanes)) {
		return;
	}
	
	dispatch(ViewerGuiActions.clearColorOverrides());
	await ViewerService.setViewpoint(view);
	const overrides = toGroupPropertiesDicts(view?.state?.colored || []);
	TicketsCardActionsDispatchers.setOverrides(overrides);

	const transformations = toTranformationsDict(view?.state?.transformed || []);
	TicketsCardActionsDispatchers.setTransformations(transformations);

	await ViewerService.clearHighlights();

	if (view?.state) {
		dispatch(TreeActions.setHiddenGeometryVisible(!!view.state.showHidden));
	}

	const v4HiddenObjects = convertToV4GroupNodes(view.state?.hidden?.flatMap((hiddenOverride) => (hiddenOverride.group as Group)?.objects || []));
	if (v4HiddenObjects.length) {
		dispatch(TreeActions.hideNodesBySharedIds(v4HiddenObjects, true));
	} else {
		dispatch(TreeActions.showAllNodes());
	}
};
