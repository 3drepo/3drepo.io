/**
 *  Copyright (C) 2023 3D Repo Ltd
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
import { Viewpoint, ViewpointGroupHierarchy, ViewpointGroupHierarchyType, ViewpointGroup, ViewpointState } from '@/v5/store/tickets/tickets.types';
import { getGroupHexColor, rgbaToHex } from '@/v4/helpers/colors';
import { generateViewpoint as generateViewpointV4, getNodesIdsFromSharedIds, toSharedIds } from '@/v4/helpers/viewpoints';
import { formatMessage } from '@/v5/services/intl';
import { getState } from '@/v4/modules/store';
import { isEmpty, isString } from 'lodash';
import { selectCurrentTeamspace } from '../store/teamspaces/teamspaces.selectors';

const convertToV5GroupHierarchy = (group: any, type: ViewpointGroupHierarchyType): ViewpointGroupHierarchy => {
	let description = '';
	let name = '';
	switch (type) {
		case ViewpointGroupHierarchyType.Colour:
			// eslint-disable-next-line no-case-declarations
			const color = rgbaToHex(group.color.join(','));
			description = formatMessage({ id: 'viewpoint.autogeneratedColorGroup.description', defaultMessage: 'Autogenerated group from viewer for colour {color}' }, { color });
			name = formatMessage({ id: 'viewpoint.autogeneratedColorGroup.name', defaultMessage: 'Default {color} group' }, { color });
			break;
		case ViewpointGroupHierarchyType.Transform:
			description = formatMessage({ id: 'viewpoint.autogeneratedTransformGroup.description', defaultMessage: 'Autogenerated group from viewer for transform' });
			name = formatMessage({ id: 'viewpoint.autogeneratedTransformGroup.name', defaultMessage: 'Default transform' });
			break;
		default:
			description = formatMessage({ id: 'viewpoint.autogeneratedColorHidden.description', defaultMessage: 'Autogenerated hidden group from viewer' });
			name = formatMessage({ id: 'viewpoint.autogeneratedColorHidden.name', defaultMessage: 'Default hidden' });
			break;
	}

	const hierarchy:ViewpointGroupHierarchy = { group: { description, name } };

	(hierarchy.group as ViewpointGroup).objects = group.objects.map((object) => (
		{ container: object.model as string, _ids: getNodesIdsFromSharedIds([object]) }
	));

	if (group.color) {
		const { color } = group;
		if (color.length > 3) {
			hierarchy.opacity = color.pop() / 255;
		}
		hierarchy.color = color;
	}

	if (group.opacity) {
		const { opacity } = group;
		hierarchy.opacity = opacity;
	}

	return hierarchy;
};

export const getViewerState = async () => {
	const { viewpoint: viewpointV4 } = await generateViewpointV4();

	const state: ViewpointState = { showDefaultHidden: !viewpointV4.hideIfc };

	if (viewpointV4.override_groups?.length) {
		state.colored = viewpointV4.override_groups.map((group) => convertToV5GroupHierarchy(group, ViewpointGroupHierarchyType.Colour));
	}

	if (viewpointV4.hidden_group) {
		state.hidden = [convertToV5GroupHierarchy(viewpointV4.hidden_group, ViewpointGroupHierarchyType.Hidden)];
	}

	if (viewpointV4.transformation_groups) {
		state.transformed = viewpointV4.transformation_groups.map((group) => convertToV5GroupHierarchy(group, ViewpointGroupHierarchyType.Transform));
	}

	return state;
};

const mergeGroups = (groups: any[]) => {
	const objects = groups.reduce((partialObjects, group) => [...partialObjects, ...group.objects], []);
	return { objects };
};

const convertToV4Group = (groupsHierarchy: ViewpointGroupHierarchy) => {
	const account = selectCurrentTeamspace(getState());
	const { color, opacity, group: v5Group } = groupsHierarchy;

	if (isString(v5Group)) {
		return { color: [0, 0, 0, 0], objects: [] }; // theres no info yet so I say us an empty group
	}

	const group:any = {
		objects: v5Group.objects.map(({ container: model, _ids }) => ({ account, model, shared_ids: toSharedIds(_ids) })),
	};

	if (color) {
		group.color = getGroupHexColor([...color, (opacity ?? 1) * 255]);
	}

	if (opacity) {
		group.opacity = opacity;
	}

	return group;
};

export const viewpointV5ToV4 = (viewpoint: Viewpoint) => {
	let v4Viewpoint:any = {};
	if (viewpoint.camera) {
		// eslint-disable-next-line @typescript-eslint/naming-convention
		const { position, up, forward: view_dir, type, size: orthographicSize } = viewpoint.camera;
		v4Viewpoint = { position, up, view_dir, type, orthographicSize, look_at: null, account: null, model: null };
	}

	if (!isEmpty(viewpoint.state)) {
		v4Viewpoint.hideIfc = !viewpoint.state.hidden;
	}

	if (!isEmpty(viewpoint.clippingPlanes)) {
		v4Viewpoint.clippingPlanes = viewpoint.clippingPlanes;
	}

	if (!isEmpty(viewpoint.state?.colored)) {
		v4Viewpoint.override_groups = viewpoint.state.colored.map(convertToV4Group);
	}

	if (!isEmpty(viewpoint.state?.transformed)) {
		v4Viewpoint.transformation_groups = viewpoint.state.transformed.map(convertToV4Group);
	}

	if (!isEmpty(viewpoint.state?.hidden)) {
		v4Viewpoint.hidden_group = mergeGroups(viewpoint.state.hidden.map(convertToV4Group));
	}

	return { viewpoint: v4Viewpoint };
};
