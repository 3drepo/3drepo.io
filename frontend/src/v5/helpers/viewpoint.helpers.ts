/**
 *  Copyright (C) 2023 3D Repo Ltd
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
import { Viewpoint, Group, ViewpointGroupOverrideType, GroupOverride, ViewpointState, V4GroupObjects, OverridesDicts } from '@/v5/store/tickets/tickets.types';
import { generateViewpoint as generateViewpointV4, getNodesIdsFromSharedIds, setGroupData, toSharedIds } from '@/v4/helpers/viewpoints';
import { formatMessage } from '@/v5/services/intl';
import { isEmpty, isString } from 'lodash';
import { selectCurrentTeamspace } from '../store/teamspaces/teamspaces.selectors';
import { ViewpointsActionsDispatchers } from '../services/actionsDispatchers';
import { getState, dispatch } from './redux.helpers';
import { getGroupHexColor, rgbToHex } from './colors.helper';
import { groupsOfViewpoint, selectViewpointsGroups, selectViewpointsGroupsBeingLoaded, ViewpointsActions } from '@/v4/modules/viewpoints';
import { getGroup as APIgetGroup } from '@/v4/services/api/groups';
import { prepareGroup } from '@/v4/helpers/groups';
import { selectCurrentRevisionId, selectIsFederation } from '@/v4/modules/model/model.selectors';

export const convertToV5GroupNodes = (objects) => objects.map((object) => ({
	container: object.model as string,
	_ids: getNodesIdsFromSharedIds([object]),
}));

export const convertToV4GroupNodes = (objects = []) => objects.map(({ container: model, _ids }) => ({
	account: selectCurrentTeamspace(getState()),
	model,
	shared_ids: toSharedIds(_ids),
}));

const convertToV5GroupOverride = (group: any, type: ViewpointGroupOverrideType): GroupOverride => {
	let description = '';
	let name = '';
	switch (type) {
		case ViewpointGroupOverrideType.COLORED:
			const color = rgbToHex(group.color);
			description = formatMessage({ id: 'viewpoint.autogeneratedColoredGroup.description', defaultMessage: 'Autogenerated group from viewer for colour {color}' }, { color });
			name = formatMessage({ id: 'viewpoint.autogeneratedColoredGroup.name', defaultMessage: 'Default {color} group' }, { color });
			break;
		case ViewpointGroupOverrideType.TRANSFORMED:
			description = formatMessage({ id: 'viewpoint.autogeneratedTransformedGroup.description', defaultMessage: 'Autogenerated group from viewer for transform' });
			name = formatMessage({ id: 'viewpoint.autogeneratedTransformedGroup.name', defaultMessage: 'Default transform' });
			break;
		default:
			description = formatMessage({ id: 'viewpoint.autogeneratedHiddenGroup.description', defaultMessage: 'Autogenerated hidden group from viewer' });
			name = formatMessage({ id: 'viewpoint.autogeneratedHiddenGroup.name', defaultMessage: 'Default hidden' });
			break;
	}

	const override:GroupOverride = { group: { description, name } };

	(override.group as Group).objects = convertToV5GroupNodes(group.objects);

	if (group.color) {
		const { color } = group;
		if (color.length > 3) {
			override.opacity = color.pop() / 255;
		}
		override.color = color;
	}

	if (group.opacity) {
		const { opacity } = group;
		override.opacity = opacity;
	}

	if (group.transformation) {
		const { transformation } = group;
		override.transformation = transformation;
	}


	return override;
};

export const getViewerState = async () => {
	const { viewpoint: viewpointV4 } = await generateViewpointV4();

	const state: ViewpointState = { showHidden: !viewpointV4.hideIfc };

	if (viewpointV4.override_groups?.length) {
		state.colored = viewpointV4.override_groups.map((group) => convertToV5GroupOverride(group, ViewpointGroupOverrideType.COLORED));
	}

	if (viewpointV4.highlighted_group) {
		state.colored = (state.colored || [])
			.concat(convertToV5GroupOverride(viewpointV4.highlighted_group, ViewpointGroupOverrideType.COLORED))
			// eslint-disable-next-line no-underscore-dangle
			.filter(({ group }) => !!(group as Group).objects.filter((obj) => obj._ids.length).length);
	}

	if (viewpointV4.hidden_group) {
		state.hidden = [convertToV5GroupOverride(viewpointV4.hidden_group, ViewpointGroupOverrideType.HIDDEN)];
	}

	if (viewpointV4.transformation_groups) {
		state.transformed = viewpointV4.transformation_groups.map((group) => convertToV5GroupOverride(group, ViewpointGroupOverrideType.TRANSFORMED));
	}

	return state;
};

const convertToV4Group = (groupOverride: GroupOverride) => {
	const { color, opacity, transformation, group: v5Group } = groupOverride;

	if (isString(v5Group)) {
		return { color: [0, 0, 0, 0], objects: [] }; // theres no info yet so I say us an empty group
	}

	const group:any = {
		objects: convertToV4GroupNodes(v5Group?.objects || []),
	};

	if (color) {
		group.color = getGroupHexColor([...color, Math.round((opacity ?? 1) * 255)]);
	}

	if (opacity) {
		group.opacity = opacity;
	}

	if (transformation) {
		group.transformation = transformation;
	}

	return group;
};

const mergeGroups = (groups: any[]) => ({ objects: groups.flatMap((group) => group.objects) });

export const viewpointV5ToV4 = (viewpoint: Viewpoint) => {
	let v4Viewpoint:any = {};
	if (viewpoint.camera) {
		// eslint-disable-next-line @typescript-eslint/naming-convention
		const { position, up, forward: view_dir, type, size: orthographicSize } = viewpoint.camera;
		v4Viewpoint = { position, up, view_dir, type, orthographicSize, look_at: null, account: null, model: null };
	}

	if (!isEmpty(viewpoint.state)) {
		v4Viewpoint.hideIfc = !viewpoint.state.hidden;
	}

	if (!isEmpty(viewpoint.clippingPlanes)) {
		v4Viewpoint.clippingPlanes = viewpoint.clippingPlanes;
	}

	if (!isEmpty(viewpoint.state?.transformed)) {
		v4Viewpoint.transformation_groups = viewpoint.state.transformed.map(convertToV4Group);
	}


	if (!isEmpty(viewpoint.state?.colored)) {
		v4Viewpoint.override_groups = viewpoint.state.colored.map(convertToV4Group);
	}
	
	if (!isEmpty(viewpoint.state?.hidden)) {
		v4Viewpoint.hidden_group = mergeGroups(viewpoint.state.hidden.map(convertToV4Group));
	}

	return { viewpoint: v4Viewpoint };
};

export const meshObjectsToV5GroupNode = (objects) => objects.map((obj) => ({
	container: obj.model,
	_ids: obj.mesh_ids,
}));

export const toGroupPropertiesDicts = (overrides: GroupOverride[]): OverridesDicts => {
	const toMeshDictionary = (objects: V4GroupObjects, color: string, opacity: number): OverridesDicts => 
		objects.shared_ids.reduce((dict, id) => {
			if (color !== undefined) {
			// eslint-disable-next-line no-param-reassign
				dict.overrides[id] = color;
			} 

			if (opacity !== undefined) {
			// eslint-disable-next-line no-param-reassign
				dict.transparencies[id] = opacity;
			}

			return dict;
		}, { overrides: {}, transparencies: {} } as OverridesDicts);

	return overrides.reduce((acum, current) => {
		const color = current.color ? getGroupHexColor(current.color) : undefined;
		const { opacity } = current;
		const v4Objects = convertToV4GroupNodes((current.group as Group)?.objects || []);

		return v4Objects.reduce((dict, objects) => {
			const overrideDict = toMeshDictionary(objects, color, opacity);

			// eslint-disable-next-line no-param-reassign
			dict.overrides = { ...dict.overrides, ...overrideDict.overrides };
			// eslint-disable-next-line no-param-reassign
			dict.transparencies = { ...dict.transparencies, ...overrideDict.transparencies };

			return dict;
		}, acum);
	}, { overrides: {}, transparencies: {} } as OverridesDicts);
};

export const goToView = async (view: Viewpoint) => {
	if (
		isEmpty(view?.state?.colored) && 
		isEmpty(view?.state?.hidden) && 
		isEmpty(view?.state?.transformed) && 
		isEmpty(view?.camera) && 
		isEmpty(view?.clippingPlanes)) {
		return;
	}
	
	ViewpointsActionsDispatchers.showViewpoint(null, null, viewpointV5ToV4(view));
};


export const getViewpointWithGroups = async ({ teamspace, modelId, view }) => {
	if (!view.viewpoint) {
		return null;
	}

	const revision = selectIsFederation(getState()) ? null : selectCurrentRevisionId(getState());
	const viewpointsGroups = selectViewpointsGroups(getState());
	const viewpointsGroupsBeingLoaded: Set<string> = selectViewpointsGroupsBeingLoaded(getState());

	const viewpoint = view.viewpoint;

	const groupsToFetch = [];

	// This part discriminates which groups hasnt been loaded yet and add their ids to
	// the groupsToFetch array
	const ids = [];
	for (const id of groupsOfViewpoint(viewpoint)) {
		ids.push(id);
		if (!viewpointsGroups[id] && !viewpointsGroupsBeingLoaded.has(id)) {
			groupsToFetch.push(id);
		}
	}

	if (groupsToFetch.length > 0) {
		dispatch(ViewpointsActions.addViewpointGroupsBeingLoaded(groupsToFetch));
		const fetchedGroups =  (await Promise.all(groupsToFetch.map((groupId) =>
			APIgetGroup(teamspace, modelId, groupId, revision))))
			.map(({ data }) => prepareGroup(data));


		fetchedGroups.map((group) => dispatch(ViewpointsActions.fetchGroupSuccess(group)));
	}

	const groupsMap = selectViewpointsGroups(getState());
	return setGroupData(viewpoint, groupsMap);
};
